<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="conor.20160606053544.1" a="E"><vh>Files to write</vh>
<v t="conor.20160605011037.1" a="E"><vh>@path ~/orgmap/leo/text-nodes</vh>
<v t="conor.20160605011510.1"><vh>@auto log.org</vh></v>
<v t="conor.20160605013539.1" a="E"><vh>@auto specter.org</vh></v>
</v>
<v t="conor.20160605013848.1"><vh>@auto datascript.org</vh></v>
<v t="conor.20160605010926.1" a="E"><vh>@path src/</vh>
<v t="conor.20160605011023.2" a="E"><vh>/clj/</vh>
<v t="conor.20160605011025.1" a="E"><vh>/text_nodes/</vh>
<v t="conor.20160606052632.1" a="E"
expanded="conor.20160606053224.1,conor.20160606062933.1,conor.20160606065151.1,conor.20160606073225.1,conor.20160606070500.1,"><vh>@file spec-test.clj</vh></v>
<v t="conor.20160605012522.1" a="E"><vh>@auto core.clj</vh></v>
<v t="conor.20160605011026.1"><vh>css.clj</vh></v>
</v>
</v>
<v t="conor.20160605011023.1" a="E"><vh>/cljs/</vh>
<v t="conor.20160605011952.1" a="E"><vh>/text_nodes/</vh>
<v t="conor.20160605011953.6"><vh>config.cljs</vh></v>
<v t="conor.20160605011953.5"><vh>@auto core.cljs</vh></v>
<v t="conor.20160605011953.4"><vh>@auto db.cljs</vh></v>
<v t="conor.20160605011953.3"><vh>@auto handlers.cljs</vh></v>
<v t="conor.20160605011953.2"><vh>@auto subs.cljs</vh></v>
<v t="conor.20160605011953.1"><vh>@auto views.cljs</vh></v>
</v>
</v>
</v>
</v>
<v t="conor.20160606044649.1" a="E"><vh>Mon Jun  6 </vh>
<v t="conor.20160606053804.1"><vh>break</vh></v>
<v t="conor.20160606055117.1"><vh>Discovery  05:55:43</vh>
<v t="conor.20160606055120.1"><vh>Working with Leo and Emacs</vh>
<v t="conor.20160606055158.1"><vh>changing a file in emacs will collapse leo heirarch</vh></v>
</v>
</v>
<v t="conor.20160606055555.1"><vh>create timestamp  --05:57:57</vh></v>
<v t="conor.20160606055940.1"><vh>break 05:59:42--06:35:58</vh></v>
<v t="conor.20160606063559.1" a="E"><vh>splitting strings 06:36:09--06:45:07</vh>
<v t="conor.20160606063703.1"><vh>tangent -- processing cljs files in leo</vh></v>
<v t="conor.20160606063153.1" a="E"><vh>splitting the string with types</vh>
<v t="conor.20160606073324.1"><vh>sampletext</vh></v>
<v t="conor.20160606064205.1"><vh>(defn count-tabs  [string]  </vh></v>
<v t="conor.20160606064205.2"><vh>(defn parsed [text]  (-&gt;&gt; </vh></v>
<v t="conor.20160606064219.1"><vh>(parsed sampletext)</vh></v>
</v>
</v>
<v t="conor.20160606064547.1" a="E"><vh>where to use the types</vh>
<v t="conor.20160606064613.1"><vh>1.  As the string is being processed into a depth-array</vh></v>
<v t="conor.20160606064654.1" a="E"><vh>2.  As the depth-array is being handed into the node</vh>
<v t="conor.20160606064711.1"><vh>edges</vh></v>
<v t="conor.20160606065408.1" a="E"><vh>How to grab the first part of a string and use it in a a spec</vh>
<v t="conor.20160606065211.1"><vh>person spec</vh></v>
</v>
</v>
</v>
<v t="conor.20160606074702.1" a="E"><vh>Got basic parsing --- but complexting the specing of a node with it's create</vh>
<v t="conor.20160606074754.1" a="E"><vh>Edge Spec</vh>
<v t="conor.20160606074754.2"><vh>person spec</vh></v>
<v t="conor.20160606074754.3"><vh>role spec</vh></v>
<v t="conor.20160606074754.4"><vh>edge</vh></v>
<v t="conor.20160606074754.5"><vh>edges</vh></v>
<v t="conor.20160606074754.7"><vh>returning the conformed value</vh></v>
</v>
<v t="conor.20160606081759.1" a="E"><vh>How to check if the beginning of a string matches value in list, and remove it if it does</vh>
<v t="conor.20160606081839.1" a="E"><vh>use a trie</vh>
<v t="conor.20160606081845.1"><vh>https://en.wikipedia.org/wiki/Trie</vh></v>
<v t="conor.20160606081847.1"><vh>Trie in clojure</vh></v>
</v>
<v t="conor.20160606082052.1" a="E"><vh>Extract current thing into higher order function using cond or conform</vh>
<v t="conor.20160606082147.1" a="E"><vh>Edge Spec</vh>
<v t="conor.20160606082147.2"><vh>person spec</vh></v>
<v t="conor.20160606082147.3"><vh>role spec</vh></v>
<v t="conor.20160606082147.4"><vh>edge</vh></v>
<v t="conor.20160606082147.5"><vh>edges</vh></v>
<v t="conor.20160606082147.6" a="E"><vh>Test the Edgespec</vh>
<v t="conor.20160606082147.7"><vh>returning the conformed value</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="conor.20160606053224.1" a="E"><vh>spec-test</vh>
<v t="conor.20160605013418.1"><vh>namespace</vh></v>
<v t="conor.20160606062933.1" a="E"><vh>string spec</vh>
<v t="conor.20160606062941.1"><vh>sampletext</vh></v>
<v t="conor.20160606065151.1" a="E"><vh>Edge Spec</vh>
<v t="conor.20160606065211.1"></v>
<v t="conor.20160606070318.1"><vh>role spec</vh></v>
<v t="conor.20160606074329.1"><vh>edge</vh></v>
<v t="conor.20160606064711.1"></v>
</v>
<v t="conor.20160606073225.1" a="E"><vh>splitting the string with types</vh>
<v t="conor.20160606073225.2"><vh>(defn count-tabs  [string]  </vh></v>
<v t="conor.20160606075341.1"><vh>experiment with re-seq</vh></v>
<v t="conor.20160606073225.3"><vh>(defn parsed [text]  (-&gt;&gt; </vh></v>
</v>
<v t="conor.20160606070500.1" a="E"><vh>Test the Edgespec</vh>
<v t="conor.20160606070517.1"><vh>returning the conformed value</vh></v>
</v>
</v>
</v>
<v t="conor.20160606074855.1" a="E"><vh>Recovered Nodes</vh>
<v t="conor.20160606074855.2"><vh>Recovered node "edges" from @file spec-test.clj</vh>
<v t="conor.20160606074855.3"><vh>old:edges</vh></v>
<v t="conor.20160606074855.4"><vh>new:edges</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="conor.20160605010926.1"></t>
<t tx="conor.20160605011023.1">@path cljs</t>
<t tx="conor.20160605011023.2">@path clj</t>
<t tx="conor.20160605011025.1">@path text_nodes</t>
<t tx="conor.20160605011026.1"></t>
<t tx="conor.20160605011037.1"></t>
<t tx="conor.20160605011952.1">@path text_nodes</t>
<t tx="conor.20160605011953.6"></t>
<t tx="conor.20160605013418.1">(ns text-nodes.core
  (:require [com.rpl.specter  :as sp :refer [ALL]]
                [clojure.spec        :as s]
                [clojure.string      :as str]
                [clojure.pprint       :refer [pprint]]
                [datascript.core    :as db])
  (:use 
   [com.rpl.specter.macros 
         :only [select transform defprotocolpath
                extend-protocolpath]]))
</t>
<t tx="conor.20160606044649.1">04:46:54 2016

adding in new clojure
currently figwheel is working fine

Mon Jun  6 04:35:04 2016
shower

Mon Jun  6 05:00:52 2016  
realized that won't be able to use spec in cljs
instead will pull down learnspecter and work off that project first

Mon Jun  6 05:15:15 2016
Alex did not leave me with a version that works

Mon Jun  6 05:24:02 2016
back to text nodes

</t>
<t tx="conor.20160606053224.1"></t>
<t tx="conor.20160606053544.1"></t>
<t tx="conor.20160606053804.1">start --  Mon Jun  6 05:38:14 2016

end -- Mon Jun  6 05:51:13 2016

start</t>
<t tx="conor.20160606055117.1"></t>
<t tx="conor.20160606055120.1"></t>
<t tx="conor.20160606055158.1">fixed this via getting rid of the hook for save-all on leave focus within my emacs

its currently commented out

</t>
<t tx="conor.20160606055555.1">In textexpander

%H:%M:%S
for time;;
</t>
<t tx="conor.20160606055940.1"></t>
<t tx="conor.20160606062933.1"></t>
<t tx="conor.20160606062941.1">(def sampletext "This is the first goal\n\tThis is it's first child\n\t\t:person Conor")
</t>
<t tx="conor.20160606063153.1">@others
</t>
<t tx="conor.20160606063559.1"></t>
<t tx="conor.20160606063703.1">
note -- working with @file's in leo is way nicer than alternatives

seeing the sentinals is actually pretty great -- at least within the clj files

need to find a way to do that
</t>
<t tx="conor.20160606064205.1">(defn count-tabs
  [string]
  (count (take-while #{\tab} string)))
  
</t>
<t tx="conor.20160606064205.2">
(defn parsed [text]
  (-&gt;&gt; (str/split text #"\n")
       (map (juxt count-tabs str/trim))))

</t>
<t tx="conor.20160606064219.1">(parsed sampletext)


</t>
<t tx="conor.20160606064547.1"></t>
<t tx="conor.20160606064613.1"></t>
<t tx="conor.20160606064654.1"></t>
<t tx="conor.20160606064711.1">(s/def ::edges (s/or 
                :edge   ::edge
                :node   string?))

</t>
<t tx="conor.20160606065151.1"></t>
<t tx="conor.20160606065211.1">(s/def ::person (s/and string? #(str/starts-with?  %  ":person")))
                                   
</t>
<t tx="conor.20160606065408.1"></t>
<t tx="conor.20160606070318.1">(s/def ::role  (s/and string?  #(re-matches #":role" %)))

</t>
<t tx="conor.20160606070500.1"></t>
<t tx="conor.20160606070517.1">(for [[i t] (parsed sampletext)]
    [i (s/conform ::edges t)])
    
    
</t>
<t tx="conor.20160606073225.1">@others
</t>
<t tx="conor.20160606073225.2">(defn count-tabs
  [string]
  (count (take-while #{\tab} string)))
  
</t>
<t tx="conor.20160606073225.3">
(defn parsed [text]
  (-&gt;&gt; (str/split text #"\n")
       (map (juxt count-tabs str/trim))))

</t>
<t tx="conor.20160606073324.1">(def sampletext "This is the first goal\n\tThis is it's first child\n\t\t:person Conor")
</t>
<t tx="conor.20160606074329.1">(s/def ::edge 
    (s/or 
        :person ::person
        :role ::role))
</t>
<t tx="conor.20160606074702.1"></t>
<t tx="conor.20160606074754.1"></t>
<t tx="conor.20160606074754.2">(s/def ::person (s/and string? #(str/starts-with?  %  ":person")))
                                   
</t>
<t tx="conor.20160606074754.3">(s/def ::role  (s/and string?  #(re-matches #":role" %)))

</t>
<t tx="conor.20160606074754.4">(s/def ::edge 
    (s/or 
        :person ::person
        :role ::role))</t>
<t tx="conor.20160606074754.5">(s/def ::edges (s/or 
                :edge  ::edge
                :node   string?))

</t>
<t tx="conor.20160606074754.7">(for [[i t] (parsed sampletext)]
    [i (s/conform ::edges t)])
    
    
</t>
<t tx="conor.20160606074855.1"></t>
<t tx="conor.20160606074855.2">(uncached) conor.20160606064711.1
Diff...
  (s/def ::edges (s/or 
-                 :edge   ::edge
?                       ^    ^^^
+                 :edge #{::person ::role}
?                       ^^^^^^^^^^   +++ ^
                  :node   string?))
  
</t>
<t tx="conor.20160606074855.3">(s/def ::edges (s/or 
                :edge #{::person ::role}
                :node   string?))

</t>
<t tx="conor.20160606074855.4">(s/def ::edges (s/or 
                :edge   ::edge
                :node   string?))

</t>
<t tx="conor.20160606075341.1">







</t>
<t tx="conor.20160606081759.1"></t>
<t tx="conor.20160606081839.1"></t>
<t tx="conor.20160606081845.1"></t>
<t tx="conor.20160606081847.1">(defn build-trie [seed &amp; kvs]
  (reduce
   (fn [trie [k v]]
     (assoc-in trie (concat k [:val]) v))
   seed
   (partition 2 kvs)))

(defn prefix-match [target trie]
  (when (seq target)
    (when-let [node (trie (first target))]
      (or (:val node)
          (recur (rest target) node)))))
          
          
          
;; (def trie (build-trie {} "foo" :baz "meh" :qux))

;;;  {\m {\e {\h {:val :qux}}}, \f {\o {\o {:val :baz}}}}


;;  (prefix-match "foobar" trie)
;;  :baz
;;   (prefix-match "foo" trie)
;;   :baz
;;   (prefix-match "f" trie)
;; 
;;   (prefix-match "abcd" trie)
;;    nil
</t>
<t tx="conor.20160606082052.1">Better solution, 

process edge


[:person  ":person Conor"]</t>
<t tx="conor.20160606082147.1"></t>
<t tx="conor.20160606082147.2">(s/def ::person (s/and string? #(str/starts-with?  %  ":person")))
                                   
</t>
<t tx="conor.20160606082147.3">(s/def ::role  (s/and string?  #(re-matches #":role" %)))

</t>
<t tx="conor.20160606082147.4">(s/def ::edge 
    (s/or 
        :person ::person
        :role ::role))
</t>
<t tx="conor.20160606082147.5">(s/def ::edges (s/or 
                :edge   ::edge
                :node   string?))

</t>
<t tx="conor.20160606082147.6"></t>
<t tx="conor.20160606082147.7">(for [[i t] (parsed sampletext)]
    [i (s/conform ::edges t)])
    
    
</t>
</tnodes>
</leo_file>
