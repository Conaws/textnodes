<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="conor.20160606053544.1" a="E"><vh>Files to write</vh>
<v t="conor.20160605011037.1" a="E"><vh>@path ~/orgmap/leo/text-nodes</vh>
<v t="conor.20160605011510.1" a="E"><vh>@auto log.org</vh></v>
<v t="conor.20160605013539.1"><vh>@auto specter.org</vh></v>
</v>
<v t="conor.20160605013848.1"><vh>@auto datascript.org</vh></v>
<v t="conor.20160605010926.1"><vh>@path src/</vh>
<v t="conor.20160605011023.2" a="E"><vh>/clj/</vh>
<v t="conor.20160605011025.1" a="E"><vh>/text_nodes/</vh>
<v t="conor.20160606052632.1" a="E"><vh>@file spec-test.clj</vh></v>
<v t="conor.20160605012522.1"><vh>@auto core.clj</vh></v>
<v t="conor.20160605011026.1"><vh>css.clj</vh></v>
</v>
</v>
<v t="conor.20160605011023.1"><vh>/cljs/</vh>
<v t="conor.20160605011952.1"><vh>/text_nodes/</vh>
<v t="conor.20160605011953.6"><vh>config.cljs</vh></v>
<v t="conor.20160605011953.5"><vh>@auto core.cljs</vh></v>
<v t="conor.20160605011953.4"><vh>@auto db.cljs</vh></v>
<v t="conor.20160605011953.3"><vh>@auto handlers.cljs</vh></v>
<v t="conor.20160605011953.2"><vh>@auto subs.cljs</vh></v>
<v t="conor.20160605011953.1"><vh>@auto views.cljs</vh></v>
</v>
</v>
</v>
</v>
<v t="conor.20160606044649.1" a="E"><vh>Mon Jun  6 </vh>
<v t="conor.20160606053804.1"><vh>break</vh></v>
<v t="conor.20160606055117.1"><vh>Discovery  05:55:43</vh>
<v t="conor.20160606055120.1"><vh>Working with Leo and Emacs</vh>
<v t="conor.20160606055158.1"><vh>changing a file in emacs will collapse leo heirarch</vh></v>
</v>
</v>
<v t="conor.20160606055555.1"><vh>create timestamp  --05:57:57</vh></v>
<v t="conor.20160606055940.1"><vh>break 05:59:42--06:35:58</vh></v>
<v t="conor.20160606142636.1"><vh>Trying to parse particular "edge" triggers from strings [10 hours] 06:30 -- 14:30</vh>
<v t="conor.20160606063559.1"><vh>splitting strings 06:36:09--06:45:07</vh>
<v t="conor.20160606063703.1"><vh>tangent -- processing cljs files in leo</vh></v>
<v t="conor.20160606063153.1" a="E"><vh>splitting the string with types</vh>
<v t="conor.20160606073324.1"><vh>sampletext</vh></v>
<v t="conor.20160606064205.1"><vh>(defn count-tabs  [string]  </vh></v>
<v t="conor.20160606064205.2"><vh>(defn parsed [text]  (-&gt;&gt; </vh></v>
<v t="conor.20160606064219.1"><vh>(parsed sampletext)</vh></v>
</v>
</v>
<v t="conor.20160606064547.1"><vh>where to use the types</vh>
<v t="conor.20160606064613.1"><vh>1.  As the string is being processed into a depth-array</vh></v>
<v t="conor.20160606064654.1"><vh>2.  As the depth-array is being handed into the node</vh>
<v t="conor.20160606064711.1"><vh>edges</vh></v>
<v t="conor.20160606065408.1" a="E"><vh>How to grab the first part of a string and use it in a a spec</vh>
<v t="conor.20160606065211.1"><vh>person spec</vh></v>
</v>
</v>
</v>
<v t="conor.20160606074702.1"><vh>Got basic parsing --- but complexting the specing of a node with it's create</vh>
<v t="conor.20160606074754.1"><vh>Edge Spec</vh>
<v t="conor.20160606074754.2"><vh>person spec</vh></v>
<v t="conor.20160606074754.3"><vh>role spec</vh></v>
<v t="conor.20160606074754.4"><vh>edge</vh></v>
<v t="conor.20160606074754.5"><vh>edges</vh></v>
<v t="conor.20160606074754.7"><vh>returning the conformed value</vh></v>
</v>
<v t="conor.20160606081759.1"><vh>How to check if the beginning of a string matches value in list, and remove it if it does</vh>
<v t="conor.20160606081839.1"><vh>use a trie</vh>
<v t="conor.20160606081845.1"><vh>https://en.wikipedia.org/wiki/Trie</vh></v>
<v t="conor.20160606081847.1"><vh>Trie in clojure</vh></v>
</v>
<v t="conor.20160606082052.1"><vh>Extract current thing into higher order function using cond or conform</vh>
<v t="conor.20160606082147.1"><vh>Edge Spec</vh>
<v t="conor.20160606082147.2"><vh>person spec</vh></v>
<v t="conor.20160606082147.3"><vh>role spec</vh></v>
<v t="conor.20160606082147.4"><vh>edge</vh></v>
<v t="conor.20160606082147.5"><vh>edges</vh></v>
<v t="conor.20160606082147.6"><vh>Test the Edgespec</vh>
<v t="conor.20160606082147.7"><vh>returning the conformed value</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="conor.20160606093849.1"><vh>experiment with parsing on triggers -- works for a single trigger per value </vh>
<v t="conor.20160606093907.1"><vh>(def trigger #{"@person" "@role"})</vh></v>
<v t="conor.20160606093907.2"><vh>(s/def ::string string?)</vh></v>
<v t="conor.20160606093907.3"><vh>(defn check-edges [edgeset string]  </vh></v>
<v t="conor.20160606093907.4"><vh>(s/explain ::even-parse (check-edges trigger "@person </vh></v>
</v>
<v t="conor.20160606113713.1"><vh>splitting up text</vh>
<v t="conor.20160606113722.1"><vh>Checking edges</vh>
<v t="conor.20160606113736.1"><vh>(def trigger #{"@person" "@role"})</vh></v>
<v t="conor.20160606113736.2"><vh>(s/def ::string string?)</vh></v>
<v t="conor.20160606113736.3"><vh>(s/def ::even-parse  (s/*  </vh></v>
<v t="conor.20160606113736.4"><vh>(defn check-edges [edgeset string]  </vh></v>
<v t="conor.20160606113737.1"><vh>(check-edges trigger "Conor is great </vh></v>
<v t="conor.20160606113737.2"><vh>(s/explain ::even-parse (check-edges trigger "@person </vh></v>
<v t="conor.20160606113737.3"><vh>(s/conform ::even-parse (check-edges trigger "@person </vh></v>
<v t="conor.20160606113737.4"><vh>(s/explain ::even-parse (check-edges trigger "Conor </vh></v>
<v t="conor.20160606113737.5"><vh>(s/explain ::even-parse [[":abcd" "this is </vh></v>
</v>
</v>
<v t="conor.20160606120806.1"><vh>the first way I tried to do the text for edges</vh>
<v t="conor.20160606094026.1"><vh>(def trigger #{"@person" "@role"})</vh></v>
<v t="conor.20160606114555.1"><vh>(s/def ::trigger trigger)</vh></v>
<v t="conor.20160606094026.2"><vh>(s/def ::string string?)</vh></v>
<v t="conor.20160606114644.1"><vh>(s/def ::even-parse  (s/* (s/cat :t ::trigger :string string?)))</vh></v>
<v t="conor.20160606094026.3"><vh>(defn check-edges [edgeset string]  </vh></v>
<v t="conor.20160606094026.4"><vh>(s/explain ::even-parse (check-edges trigger "@person </vh></v>
</v>
<v t="conor.20160606115351.1"><vh>clojure set functions</vh>
<v t="conor.20160606115355.1"><vh>11:53:59 --</vh>
<v t="conor.20160606115634.1"><vh>intersection</vh></v>
<v t="conor.20160606114947.1"><vh>set-members-in-string</vh></v>
</v>
</v>
<v t="conor.20160606132427.1"><vh>General Clojure lessons</vh>
<v t="conor.20160606132433.1"><vh>debugging -- do println, then return test value</vh></v>
<v t="conor.20160606132555.1"><vh>str/replace-first</vh></v>
<v t="conor.20160606132801.1"><vh>reducing pattern</vh>
<v t="conor.20160606134111.1"><vh>parsers used</vh></v>
<v t="conor.20160606141311.1"><vh>vals-between</vh>
<v t="conor.20160606141311.2"><vh>test</vh></v>
</v>
<v t="conor.20160606130151.1"><vh>WIN  reducing pattern volume 2</vh></v>
<v t="conor.20160606124013.1"><vh>WIN reducing pattern basic</vh></v>
<v t="conor.20160606134014.1"><vh>WIN  reducing pattern volume 3</vh>
<v t="conor.20160606140315.1"><vh>test</vh></v>
</v>
</v>
<v t="conor.20160606120955.1"><vh>set-members-in-string</vh></v>
</v>
<v t="conor.20160606132404.1"><vh>spec lessons</vh>
<v t="conor.20160606132252.1"><vh>useful spec lessons</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="conor.20160605010926.1"></t>
<t tx="conor.20160605011023.1">@path cljs</t>
<t tx="conor.20160605011023.2">@path clj</t>
<t tx="conor.20160605011025.1">@path text_nodes</t>
<t tx="conor.20160605011026.1"></t>
<t tx="conor.20160605011037.1"></t>
<t tx="conor.20160605011952.1">@path text_nodes</t>
<t tx="conor.20160605011953.6"></t>
<t tx="conor.20160606044649.1">04:46:54 2016

adding in new clojure
currently figwheel is working fine

Mon Jun  6 04:35:04 2016
shower

Mon Jun  6 05:00:52 2016  
realized that won't be able to use spec in cljs
instead will pull down learnspecter and work off that project first

Mon Jun  6 05:15:15 2016
Alex did not leave me with a version that works

Mon Jun  6 05:24:02 2016
back to text nodes

</t>
<t tx="conor.20160606053544.1"></t>
<t tx="conor.20160606053804.1">start --  Mon Jun  6 05:38:14 2016

end -- Mon Jun  6 05:51:13 2016

start</t>
<t tx="conor.20160606055117.1"></t>
<t tx="conor.20160606055120.1"></t>
<t tx="conor.20160606055158.1">fixed this via getting rid of the hook for save-all on leave focus within my emacs

its currently commented out

</t>
<t tx="conor.20160606055555.1">In textexpander

%H:%M:%S
for time;;
</t>
<t tx="conor.20160606055940.1"></t>
<t tx="conor.20160606063153.1">@others
</t>
<t tx="conor.20160606063559.1"></t>
<t tx="conor.20160606063703.1">
note -- working with @file's in leo is way nicer than alternatives

seeing the sentinals is actually pretty great -- at least within the clj files

need to find a way to do that
</t>
<t tx="conor.20160606064205.1">(defn count-tabs
  [string]
  (count (take-while #{\tab} string)))
  
</t>
<t tx="conor.20160606064205.2">
(defn parsed [text]
  (-&gt;&gt; (str/split text #"\n")
       (map (juxt count-tabs str/trim))))

</t>
<t tx="conor.20160606064219.1">(parsed sampletext)


</t>
<t tx="conor.20160606064547.1"></t>
<t tx="conor.20160606064613.1"></t>
<t tx="conor.20160606064654.1"></t>
<t tx="conor.20160606064711.1">(s/def ::edges (s/or 
                :edge   ::edge
                :node   string?))

</t>
<t tx="conor.20160606065211.1">(s/def ::person (s/and string? #(str/starts-with?  %  ":person")))
                                   
</t>
<t tx="conor.20160606065408.1"></t>
<t tx="conor.20160606073324.1">(def sampletext "This is the first goal\n\tThis is it's first child\n\t\t:person Conor")
</t>
<t tx="conor.20160606074702.1"></t>
<t tx="conor.20160606074754.1"></t>
<t tx="conor.20160606074754.2">(s/def ::person (s/and string? #(str/starts-with?  %  ":person")))
                                   
</t>
<t tx="conor.20160606074754.3">(s/def ::role  (s/and string?  #(re-matches #":role" %)))

</t>
<t tx="conor.20160606074754.4">(s/def ::edge 
    (s/or 
        :person ::person
        :role ::role))</t>
<t tx="conor.20160606074754.5">(s/def ::edges (s/or 
                :edge  ::edge
                :node   string?))

</t>
<t tx="conor.20160606074754.7">(for [[i t] (parsed sampletext)]
    [i (s/conform ::edges t)])
    
    
</t>
<t tx="conor.20160606081759.1"></t>
<t tx="conor.20160606081839.1"></t>
<t tx="conor.20160606081845.1"></t>
<t tx="conor.20160606081847.1">(defn build-trie [seed &amp; kvs]
  (reduce
   (fn [trie [k v]]
     (assoc-in trie (concat k [:val]) v))
   seed
   (partition 2 kvs)))

(defn prefix-match [target trie]
  (when (seq target)
    (when-let [node (trie (first target))]
      (or (:val node)
          (recur (rest target) node)))))
          
          
          
;; (def trie (build-trie {} "foo" :baz "meh" :qux))

;;;  {\m {\e {\h {:val :qux}}}, \f {\o {\o {:val :baz}}}}


;;  (prefix-match "foobar" trie)
;;  :baz
;;   (prefix-match "foo" trie)
;;   :baz
;;   (prefix-match "f" trie)
;; 
;;   (prefix-match "abcd" trie)
;;    nil
</t>
<t tx="conor.20160606082052.1">Better solution, 

process edge


[:person  ":person Conor"]</t>
<t tx="conor.20160606082147.1"></t>
<t tx="conor.20160606082147.2">(s/def ::person (s/and string? #(str/starts-with?  %  ":person")))
                                   
</t>
<t tx="conor.20160606082147.3">(s/def ::role  (s/and string?  #(re-matches #":role" %)))

</t>
<t tx="conor.20160606082147.4">(s/def ::edge 
    (s/or 
        :person ::person
        :role ::role))
</t>
<t tx="conor.20160606082147.5">(s/def ::edges (s/or 
                :edge   ::edge
                :node   string?))

</t>
<t tx="conor.20160606082147.6"></t>
<t tx="conor.20160606082147.7">(for [[i t] (parsed sampletext)]
    [i (s/conform ::edges t)])
    
    
</t>
<t tx="conor.20160606093849.1">

(def trigger #{"@person" "@role"})

(s/def ::trigger trigger)


(s/def ::string string?)

(s/def ::even-parse  (s/* 
                      (s/cat 
                       :t        ::trigger
                       :string   string?)))




(defn check-edges [edgeset string]
  (let [words (str/split string #"\s")]
    (-&gt;&gt; (split-with #(edgeset %) words)
        (partition 2)
        first
        ((juxt #(ffirst %) #(str/join " " (second %)))))))



(s/explain ::even-parse (check-edges trigger "@person Conor"))
(s/conform ::even-parse (check-edges trigger "@person Conor @role King of the World"))

(s/explain ::even-parse [[":abcd" "this is all the text"][":edf"  "that follos"]])






</t>
<t tx="conor.20160606093907.1">

(def trigger #{"@person" "@role"})

(s/def ::trigger trigger)</t>
<t tx="conor.20160606093907.2">(s/def ::string string?)

(s/def ::even-parse  (s/* 
                      (s/cat 
                       :t        ::trigger
                       :string   string?)))</t>
<t tx="conor.20160606093907.3">

(defn check-edges [edgeset string]
  (let [words (str/split string #"\s")]
    (-&gt;&gt; (split-with #(edgeset %) words)
        (partition 2)
        first
        ((juxt #(ffirst %) #(str/join " " (second %)))))))</t>
<t tx="conor.20160606093907.4">
(s/explain ::even-parse (check-edges trigger "@person Conor"))
(s/conform ::even-parse (check-edges trigger "@person Conor @role King of the World"))

(s/explain ::even-parse [[":abcd" "this is all the text"][":edf"  "that follos"]])</t>
<t tx="conor.20160606094026.1">(def trigger #{"@person" "@role"})

</t>
<t tx="conor.20160606094026.2">(s/def ::string string?)

</t>
<t tx="conor.20160606094026.3">(defn check-edges [edgeset string]
  (let [words (str/split string #"\s")]
    (-&gt;&gt; (split-with #(edgeset %) words)
        (partition 2)
        first
        ((juxt #(ffirst %) #(str/join " " (second %)))))))



</t>
<t tx="conor.20160606094026.4">(s/explain ::even-parse (check-edges trigger "@person Conor"))


(s/conform ::even-parse (check-edges trigger "@person Conor @role King of the World"))


</t>
<t tx="conor.20160606113713.1"></t>
<t tx="conor.20160606113722.1">

(def trigger #{"@person" "@role"})

(s/def ::trigger trigger)


(s/def ::string string?)

(s/def ::edgeparse (s/cat 
                    :type  ::trigger
                    :val   (s/and string? #(not (trigger %)))))


(s/def ::even-parse  (s/* 
                      (s/or :edge  ::edgeparse
                            :child (s/spec  (s/cat  )))




(defn check-edges [edgeset string]
  (loop [result [] s string]
    (let [words (str/split string #"\s")]
      (if  (edgeset (first words))
        (-&gt;&gt; (partition-by #(edgeset %) words)
             (partition 2)
             (map (juxt #(ffirst %) #(str/join " " (second %))))
             (apply conj result))
        (let [node-string (take-while #(not (edgeset %)) words)
              newval (str/join " " node-string) 
              remaining (str/replace-first s (re-pattern newval) "")]
          (if (seq remaining)
            (recur (conj result newval) remaining)
            result))))))

(comment

(check-edges trigger "@person Coonro is great @role org @person Steve")


(check-edges trigger "Conor is great @role organizer")

(str/replace-first "abcd" (re-pattern "b") "")


(s/explain ::even-parse (check-edges trigger "@person Conor"))


(s/conform ::even-parse (check-edges trigger "@person Conor @role King of the World"))

(s/explain ::even-parse (check-edges trigger "@person Conor @role King of the World"))


(s/explain ::even-parse (check-edges trigger "Conor @role King of the World"))


(s/explain ::even-parse [[":abcd" "this is all the text"][":edf"  "that follos"]])

)




</t>
<t tx="conor.20160606113736.1">

(def trigger #{"@person" "@role"})

(s/def ::trigger trigger)</t>
<t tx="conor.20160606113736.2">(s/def ::string string?)

(s/def ::edgeparse (s/cat 
                    :type  ::trigger
                    :val   (s/and string? #(not (trigger %)))))</t>
<t tx="conor.20160606113736.3">(s/def ::even-parse  (s/* 
                      (s/or :edge  ::edgeparse
                            :child (s/spec  (s/cat  )))</t>
<t tx="conor.20160606113736.4">

(defn check-edges [edgeset string]
  (loop [result [] s string]
    (let [words (str/split string #"\s")]
      (if  (edgeset (first words))
        (-&gt;&gt; (partition-by #(edgeset %) words)
             (partition 2)
             (map (juxt #(ffirst %) #(str/join " " (second %))))
             (apply conj result))
        (let [node-string (take-while #(not (edgeset %)) words)
              newval (str/join " " node-string) 
              remaining (str/replace-first s (re-pattern newval) "")]
          (if (seq remaining)
            (recur (conj result newval) remaining)
            result))))))

(comment

(check-edges trigger "@person Coonro is great @role org @person Steve")</t>
<t tx="conor.20160606113737.1">(check-edges trigger "Conor is great @role organizer")

(str/replace-first "abcd" (re-pattern "b") "")</t>
<t tx="conor.20160606113737.2">(s/explain ::even-parse (check-edges trigger "@person Conor"))</t>
<t tx="conor.20160606113737.3">(s/conform ::even-parse (check-edges trigger "@person Conor @role King of the World"))

(s/explain ::even-parse (check-edges trigger "@person Conor @role King of the World"))</t>
<t tx="conor.20160606113737.4">(s/explain ::even-parse (check-edges trigger "Conor @role King of the World"))</t>
<t tx="conor.20160606113737.5">(s/explain ::even-parse [[":abcd" "this is all the text"][":edf"  "that follos"]])

)</t>
<t tx="conor.20160606114555.1">(s/def ::trigger trigger)

</t>
<t tx="conor.20160606114644.1">(s/def ::even-parse  (s/* 
                      (s/cat 
                       :t        ::trigger
                       :string   string?)))
                       
                       
</t>
<t tx="conor.20160606114947.1">(defn members-in-string  [trigset string]
   (set/intersection trigset (str/split string #"\s")))


</t>
<t tx="conor.20160606115351.1"></t>
<t tx="conor.20160606115355.1">end Mon Jun  6 11:56:59 2016

</t>
<t tx="conor.20160606115634.1">user=&gt; (clojure.set/intersection #{1})
#{1}
user=&gt; (clojure.set/intersection #{1 2} #{2 3})
#{2}
user=&gt; (clojure.set/intersection #{1 2} #{2 3} #{3 4})
#{}
user=&gt; (clojure.set/intersection #{1 :a} #{:a 3} #{:a})
#{:a}</t>
<t tx="conor.20160606120806.1"></t>
<t tx="conor.20160606120955.1">(defn members-in-string  [trigset string]
   (set/intersection trigset (str/split string #"\s")))

(members-in-string #{"word" "other-word"} "this will show a word but no other word")

;;=&gt;  #{"word"}
</t>
<t tx="conor.20160606124013.1">

(reduce (fn [ {c :current r :result :as m} input] 
         (update m :current #(conj % input))
          #_(if (s/valid? ::not-trigger input)
            (update m :current (conj c input))
            (update m :current [input]
                    :result  (conj r c))))  
        {:current []
         :result []}  
        ["@person" "Conor" "White-Sullivan"])

</t>
<t tx="conor.20160606130151.1">
    

(reduce (fn [ {c :current r :result :as m} input] 
         (update m :current #(conj % input))
          #_(if (s/valid? ::not-trigger input)
            (update m :current (conj c input))
            (update m :current [input]
                    :result  (conj r c))))  
        {:current []
         :result []}  
        ["@person" "Conor" "White-Sullivan"])

</t>
<t tx="conor.20160606132252.1">
(def trigger #{"@person" "@role"})

(s/def ::trigger (s/or :deftrig trigger
                       :trig  #(str/starts-with? % "@")))

(s/def ::not-trigger (s/and string? #(not (trigger %))))

(s/conform ::not-trigger "Conor")

(s/valid? ::trigger "@person")

(s/conform ::trigger "@result")


(s/def ::edgeparse (s/cat 
                    :type  ::trigger
                    :val   (s/* ::not-trigger)))

(s/conform ::edgeparse  ["@person" "Conor" "White-Sullivan"])


(s/def ::even-parse  (s/* 
                      (s/or :edge  ::edgeparse
                            :child (s/spec (s/* ::not-trigger)))))
</t>
<t tx="conor.20160606132404.1"></t>
<t tx="conor.20160606132427.1"></t>
<t tx="conor.20160606132433.1">(if (do (print "hello") (= :a :b))
  :a
  :b)</t>
<t tx="conor.20160606132555.1">
(str/replace-first "abcd" (re-pattern "b") "")
</t>
<t tx="conor.20160606132801.1"></t>
<t tx="conor.20160606134014.1">


(def newsamp ["Hey" "@person" "Conor" "White-Sullivan" "@result" "nada" "@final"])


(defn vals-between [resetfn s]
  (-&gt;&gt; s
       (reduce (fn [{c :c r :r :as m} x]
                 (if (resetfn x)
                   (assoc m :c [x] :r (conj r c))
                   (assoc m :c (conj c x))))
               {:c [] :r []})
       ((fn [{c :c r :r}]  (conj r c)))))

(def parsedf
  (vals-between #(s/valid? ::trigger %) newsamp))       
                          

(pprint (s/conform ::even-parse parsedf))

</t>
<t tx="conor.20160606134111.1">
(def trigger #{"@person" "@role"})

(s/def ::trigger (s/or :deftrig trigger
                       :trig  #(str/starts-with? % "@")))

(s/def ::not-trigger (s/and string? #(not (trigger %))))


(s/def ::edgeparse (s/cat 
                    :type  ::trigger
                    :val   (s/* ::not-trigger)))


(s/def ::even-parse  (s/* 
                      (s/or :edge  ::edgeparse
                            :child (s/spec (s/* ::not-trigger)))))
</t>
<t tx="conor.20160606140315.1">(def newsampp ["a" "@person" "Conor" "White-Sullivan" "@result" "nada" "@final"]) 

(def parsedf
 (vals-betweenn #(s/valid? ::trigger %) newsampp))         



(pprint (s/conform ::even-parse parsedf))  
</t>
<t tx="conor.20160606141311.1">

(defn vals-betweenn [resetfn s]
  (-&gt;&gt; s
       (reduce (fn [{c :c r :r :as m} x]
                 (if (resetfn x)
                   (assoc m :c [x] :r (if (empty? c)
                                        r
                                        (conj r c)))
                   (assoc m :c (conj c x))))
               {:c [] :r []})
       ((fn [{c :c r :r}] (conj r c)))))


</t>
<t tx="conor.20160606141311.2">(def newsampp ["a" "@person" "Conor" "White-Sullivan" "@result" "nada" "@final"]) 

(def parsedf
 (vals-betweenn #(s/valid? ::trigger %) newsampp))         



(pprint (s/conform ::even-parse parsedf))  
</t>
<t tx="conor.20160606142636.1"></t>
</tnodes>
</leo_file>
